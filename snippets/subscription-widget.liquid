{% comment %} Shopify Subscription Widget Snippet {% endcomment %}
{% comment %} Get current variant for price calculations {% endcomment %}
{% assign current_variant = product.selected_or_first_available_variant %}
{% assign price = current_variant.price %}

{% assign discount_percentage = block.settings.sub_widget_subscription_discount | plus: 0 %}
{% assign discount_multiplier = 100 | minus: discount_percentage | divided_by: 100.0 %}


<!-- Store variant data for subscription widget -->
<script type="application/json" class="subscription-widget__variants-json">
  {{ product.variants | json }}
</script>

<script>
  // PRICE UPDATER: Updates subscription widget prices based on selected variant

  window.SubscriptionPriceUpdater = (function () {
    'use strict';

    const variantData = JSON.parse(document.querySelector('.subscription-widget__variants-json').textContent);

    // Flag to prevent infinite loops when firing events
    let isUpdating = false;
    let isFiringOwnEvent = false;

    // Store current active prices to persist when toggling plans
    let currentActivePrice = null;
    let currentActiveComparePrice = null;
    let priceUpdateTimeout = null;
    let isInitialized = false;
    let waitingForQB = false;
    let qbWaitTimeout = null;
    let pendingVariantId = null;
    let currentQBQuantity = null; // Store quantity from QB

    function formatPrice(price) {
      return new Intl.NumberFormat('{{ shop.locale }}', {
        style: 'currency',
        currency: '{{ shop.currency }}',
        minimumFractionDigits: 2,
      }).format(price / 100);
    }


    // Get current quantity from QB bundle first, then input
    function getCurrentQuantity() {
      // FIRST: If we have a stored QB quantity (from qb:price-updated event), use that
      if (currentQBQuantity !== null && currentQBQuantity > 0) {
        return currentQBQuantity;
      }

      // SECOND: Check if QB has an active option and get quantity from there
      const qbActive = document.querySelector('.qb-wrapper .qb-option.qb-active');
      if (qbActive && qbActive.dataset.qty) {
        const qbQty = parseInt(qbActive.dataset.qty);
        return qbQty;
      }

      // THIRD: Check if QB bundle data exists
      if (window.qbBundleData && window.qbBundleData.totalQty) {
        return window.qbBundleData.totalQty;
      }

      // FOURTH: Fall back to standard quantity input
      const qtyInput = document.querySelector('input[name="quantity"]');
      const inputQty = qtyInput ? parseInt(qtyInput.value) || 1 : 1;
      return inputQty;
    }

    // Wait for QB to update prices, with fallback timeout
    function waitForQBOrUpdate(variantId, fallbackDelay = 400) {
      // Cancel any previous QB wait
      if (qbWaitTimeout) {
        clearTimeout(qbWaitTimeout);
      }

      waitingForQB = true;
      pendingVariantId = variantId;

      // Set timeout as fallback if QB doesn't fire
      qbWaitTimeout = setTimeout(() => {
        if (waitingForQB && pendingVariantId === variantId) {
          // Check if QB is active - if so, don't override with non-discounted prices
          const qbActive = document.querySelector('.qb-wrapper .qb-option.qb-active');
          if (!qbActive) {
            // QB didn't fire and is not active, update with variant defaults
            waitingForQB = false;
            pendingVariantId = null;
            updatePricesForVariant(variantId);
          } else {
            // QB is active, clear waiting flag but don't update prices
            waitingForQB = false;
            pendingVariantId = null;
          }
        }
      }, fallbackDelay);
    }

    // Track last update to prevent duplicate calls within short timeframe
    let lastUpdateKey = null;
    let lastUpdateTime = 0;

    // Debounced price update to handle rapid changes
    function debouncedPriceUpdate(variantId, overridePrice = null, overrideComparePrice = null, delay = 100) {
      if (priceUpdateTimeout) {
        clearTimeout(priceUpdateTimeout);
      }

      priceUpdateTimeout = setTimeout(() => {
        updatePricesForVariant(variantId, overridePrice, overrideComparePrice);
      }, delay);
    }

    // Function to read QB state from DOM
    function getQBStateFromDOM() {
      const qbWrapper = document.querySelector('.qb-wrapper');
      const qbActive = qbWrapper?.querySelector('.qb-option.qb-active');

      if (!qbActive || !qbWrapper) {
        return { quantity: 1, discount: 0 };
      }

      const qbQuantity = parseInt(qbActive.dataset.qty) || 1;
      const optionNum = parseInt(qbActive.dataset.option) || 1;

      // Read QB discount values from wrapper's data attributes
      const qb2Discount = parseFloat(qbWrapper.dataset.qb2Discount) || 10;
      const qb3Discount = parseFloat(qbWrapper.dataset.qb3Discount) || 15;

      let qbDiscount = 0;
      switch(optionNum) {
        case 1: qbDiscount = 0; break;
        case 2: qbDiscount = qb2Discount; break;
        case 3: qbDiscount = qb3Discount; break;
      }

      return { quantity: qbQuantity, discount: qbDiscount };
    }

    function updatePricesForVariant(variantId) {
      // Prevent infinite loops
      if (isUpdating) {
        return;
      }

      isUpdating = true;

      try {
        const variant = variantData.find((v) => v.id == variantId);
        if (!variant) {
          return;
        }

        // ALWAYS read current QB state from DOM to ensure we have the latest
        const qbState = getQBStateFromDOM();

        const qbQuantity = qbState.quantity;
        const qbDiscount = qbState.discount;

        // Calculate base prices with QB discount
        let perUnitPrice = variant.price;
        let perUnitComparePrice = variant.compare_at_price || 0;

      // Apply QB discount to per-unit price
      if (qbDiscount > 0) {
        const qbMultiplier = (100 - qbDiscount) / 100;
        perUnitPrice = Math.round(perUnitPrice * qbMultiplier);
        if (perUnitComparePrice > 0) {
          perUnitComparePrice = Math.round(perUnitComparePrice * qbMultiplier);
        }
      }

      // Calculate totals with quantity
      const totalBasePrice = perUnitPrice * qbQuantity;
      const totalComparePrice = perUnitComparePrice > 0 ? perUnitComparePrice * qbQuantity : 0;

      // Calculate subscription price (with subscription discount on top of QB discount)
      const subscriptionPrice = Math.round(totalBasePrice * {{ discount_multiplier }});

      // Update subscription plan prices ONLY
      const subscriptionPlans = document.querySelectorAll('[data-plan="subscription"]');

      subscriptionPlans.forEach((plan, index) => {
        const currentPriceEl = plan.querySelector('.current-price');
        const originalPriceEl = plan.querySelector('.original-price');

        if (currentPriceEl) {
          const newPrice = formatPrice(subscriptionPrice);
          currentPriceEl.textContent = newPrice;
        }

        if (originalPriceEl) {
          const newPrice = formatPrice(totalBasePrice);
          originalPriceEl.textContent = newPrice;
        }
      });

      // Update one-time single plan prices
      const onetimeSinglePlan = document.querySelector('[data-plan="onetime-single"]');

      if (onetimeSinglePlan) {
        const currentPriceEl = onetimeSinglePlan.querySelector('.current-price');
        const originalPriceEl = onetimeSinglePlan.querySelector('.original-price');

        if (currentPriceEl) {
          const newPrice = formatPrice(totalBasePrice);
          currentPriceEl.textContent = newPrice;
        }

        if (originalPriceEl) {
          if (totalComparePrice > totalBasePrice) {
            originalPriceEl.textContent = formatPrice(totalComparePrice);
            originalPriceEl.style.display = 'inline';
          } else {
            originalPriceEl.style.display = 'none';
          }
        }
      }

      // Update one-time quarterly plan (if exists)
      const onetimeQuarterlyPlan = document.querySelector('[data-plan="onetime-quarterly"]');
      if (onetimeQuarterlyPlan) {
        const quarterlyPrice = totalBasePrice * 3 * 0.85;
        const quarterlyPricePerPack = quarterlyPrice / 3;

        const currentPriceEl = onetimeQuarterlyPlan.querySelector('.current-price');
        const originalPriceEl = onetimeQuarterlyPlan.querySelector('.original-price');

        if (currentPriceEl) {
          currentPriceEl.innerHTML = `${formatPrice(quarterlyPricePerPack)}/<span class="frequency-tag">pack</span>`;
        }
        if (originalPriceEl) {
          originalPriceEl.textContent = formatPrice(totalBasePrice * 3);
        }
      }

      // Fire QB event first so buy button has fresh QB state
      isFiringOwnEvent = true;
      document.dispatchEvent(new CustomEvent('qb:state-changed', {
        detail: {
          quantity: qbQuantity,
          qbDiscount: qbDiscount,
          basePrice: variant.price,
          baseComparePrice: variant.compare_at_price || 0
        },
        bubbles: true
      }));
      setTimeout(() => { isFiringOwnEvent = false; }, 10);

      // Fire subscription event for buy button
      const selectedPlan = document.querySelector('.plan-option.selected');
      const isSubscription = selectedPlan?.getAttribute('data-plan')?.includes('subscription');
      const subscriptionDiscount = isSubscription ? {{ discount_percentage }} : 0;

      document.dispatchEvent(new CustomEvent('subscription:state-changed', {
        detail: {
          subscriptionActive: isSubscription,
          subscriptionDiscount: subscriptionDiscount
        },
        bubbles: true
      }));

      } catch (error) {
        // Error handling
      } finally {
        // Reset flag after a short delay to allow events to propagate
        setTimeout(() => {
          isUpdating = false;
        }, 50);
      }
    }

    // Old price update code removed - buy button now handles all price calculations

    // Get best available variant (first available, or first if none available)
    function getBestVariant() {
      // First try to find an available variant
      const availableVariant = variantData.find((v) => v.available);
      if (availableVariant) {
        return availableVariant;
      }

      // If no variants are available, return the first one
      return variantData[0] || null;
    }

    // Ensure a variant is selected
    function ensureVariantSelected() {
      const form = document.querySelector('form[action*="/cart/add"]');
      const variantInput = form?.querySelector('input[name="id"]');

      if (!variantInput || !variantInput.value) {
        const bestVariant = getBestVariant();
        if (bestVariant && variantInput) {
          variantInput.value = bestVariant.id;

          // Also update any variant selectors
          const variantSelectors = document.querySelectorAll(
            '.simple-variant-picker__radio, .simple-variant-picker__select'
          );
          variantSelectors.forEach((selector) => {
            if (selector.type === 'radio' && selector.value == bestVariant.id) {
              selector.checked = true;
            } else if (selector.tagName === 'SELECT') {
              selector.value = bestVariant.id;
            }
          });

          // Trigger change event to update other components
          if (variantInput) {
            variantInput.dispatchEvent(new Event('change', { bubbles: true }));
          }

          return bestVariant.id;
        }
      }

      return variantInput?.value;
    }

    function init() {
      // Ensure a variant is selected first
      const selectedVariantId = ensureVariantSelected();

      // Update prices on variant change
      document.addEventListener('change', function (e) {
        const isVariantChange =
          e.target.classList.contains('simple-variant-picker__radio') ||
          e.target.classList.contains('simple-variant-picker__select') ||
          e.target.name === 'id' || // Direct variant ID input
          (e.target.name && e.target.name.startsWith('options[')) || // Variant option selects/radios
          e.target.closest('.product-form__input') || // Shopify default variant inputs
          e.target.type === 'radio' && e.target.closest('[id*="variant"]'); // Any radio in variant container

        if (isVariantChange) {
          setTimeout(() => {
            const form = document.querySelector('form[action*="/cart/add"]');
            const variantInput = form?.querySelector('input[name="id"]');
            let variantId = variantInput?.value;

            // If no variant selected, auto-select the best one
            if (!variantId) {
              variantId = ensureVariantSelected();
            }

            if (variantId) {

              // Update subscription widget prices
              updatePricesForVariant(variantId);

              // Fire event for buy button
              const selectedPlan = document.querySelector('.plan-option.selected');
              const isSubscription = selectedPlan?.getAttribute('data-plan')?.includes('subscription');
              const subscriptionDiscount = isSubscription ? {{ discount_percentage }} : 0;

              document.dispatchEvent(new CustomEvent('subscription:state-changed', {
                detail: {
                  subscriptionActive: isSubscription,
                  subscriptionDiscount: subscriptionDiscount
                },
                bubbles: true
              }));
            }
          }, 200);
        }
      });

      // Listen for subscription plan changes
      document.querySelectorAll('.plan-option').forEach(option => {
        option.addEventListener('click', function() {
          const plan = this.getAttribute('data-plan');
          const isSubscription = plan?.includes('subscription');
          const subscriptionDiscount = isSubscription ? {{ discount_percentage }} : 0;

          // Fire event for buy button
          document.dispatchEvent(new CustomEvent('subscription:state-changed', {
            detail: {
              subscriptionActive: isSubscription,
              subscriptionDiscount: subscriptionDiscount
            },
            bubbles: true
          }));

          // Update prices to reflect the new plan selection
          const form = document.querySelector('form[action*="/cart/add"]');
          const variantInput = form?.querySelector('input[name="id"]');
          const variantId = variantInput?.value;

          if (variantId) {
            updatePricesForVariant(variantId);
          }
        });
      });

      // Listen for QB state changes to update subscription widget prices
      document.addEventListener('qb:state-changed', function(e) {
        // Skip if this is our own event to prevent loops
        if (isFiringOwnEvent) {
          return;
        }

        const form = document.querySelector('form[action*="/cart/add"]');
        const variantInput = form?.querySelector('input[name="id"]');
        const variantId = variantInput?.value;

        if (variantId) {
          // Function will read QB state from DOM
          updatePricesForVariant(variantId);
        }
      });

      // Initial price update with current variant
      setTimeout(() => {
        const form = document.querySelector('form[action*="/cart/add"]');
        const variantInput = form?.querySelector('input[name="id"]');
        const variantId = variantInput?.value;

        if (variantId) {
          updatePricesForVariant(variantId);
        }
      }, 200);

      isInitialized = true;
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    return {
      init: init,
      // updatePricesForVariant is now disabled
      updatePricesForVariant: function() { }
    };
  })();

  // OLD CODE BELOW THIS LINE WAS REMOVED
  /*
  The following code was removed as buy button now handles all price calculations:
  - All price DOM update logic
  - QB price event listeners
  - Subscription plan price updates
  */
</script>

{% comment %} END OF SUBSCRIPTION WIDGET SCRIPT {% endcomment %}

{% comment %} Subscription widget CSS and HTML below {% endcomment %}

<style>

.subscription-widget {
  margin-top: {{ block.settings.sub_widget_section_margin_top | default: 0 }}px;
  margin-bottom: {{ block.settings.sub_widget_section_margin_bottom | default: 0 }}px;
  width: 100%;
  font-family: inherit;
  display: flex;
  flex-direction: {% if block.settings.sub_widget_sub_first %}column-reverse{% else %}column{% endif %};
  gap: {{ block.settings.sub_widget_buttons_gap }}px;
}

  .price-per {
      font-size: 12px;
      gap: 5px;
      display: flex;
      line-height: 18px;
      align-items: center;
  }

  .plan-option {
      border: {{ block.settings.sub_widget_button_border_width }}px solid {{ block.settings.sub_widget_button_border_color }};
      border-radius: {{ block.settings.sub_widget_button_border_radius }}px;
      cursor: pointer;
      position: relative;
      background: {{ block.settings.sub_widget_button_bg_color }};
          case 1: qbDiscount = 0; break;
          case 2: qbDiscount = {{ qb2_discount }}; break;
          case 3: qbDiscount = {{ qb3_discount }}; break;
        }
      }

      // Check for global ProductState first
      if (window.ProductState && window.ProductState.basePrice > 0 && !overridePrice) {
        overridePrice = window.ProductState.basePrice;
        overrideComparePrice = window.ProductState.comparePrice;
      }

      const variant = variantData.find((v) => v.id == variantId);
      if (!variant) {
        return;
      }

      // Get current quantity
      const quantity = getCurrentQuantity();

      let totalBasePrice, totalComparePrice, perUnitBasePrice, perUnitComparePrice;

      // Check if we have QB override prices
      if (overridePrice !== null) {
        // QB prices are already TOTAL prices (quantity already applied by QB)
        totalBasePrice = overridePrice;
        totalComparePrice = overrideComparePrice;

        // Calculate per-unit prices by dividing by quantity
        perUnitBasePrice = totalBasePrice / quantity;
        perUnitComparePrice = totalComparePrice ? totalComparePrice / quantity : null;

        // Store the TOTAL prices for future plan toggles
        currentActivePrice = totalBasePrice;
        currentActiveComparePrice = totalComparePrice;
      } else {
        // No QB override prices - calculate from variant prices + QB discount
        perUnitBasePrice = variant.price;
        perUnitComparePrice = variant.compare_at_price;

        // Apply QB discount if active
        if (qbDiscount > 0) {
          const discountMultiplier = (100 - qbDiscount) / 100;
          perUnitBasePrice = Math.round(perUnitBasePrice * discountMultiplier);
          if (perUnitComparePrice) {
            perUnitComparePrice = Math.round(perUnitComparePrice * discountMultiplier);
          }
        }

        // Calculate totals by multiplying by quantity
        totalBasePrice = perUnitBasePrice * quantity;
        totalComparePrice = perUnitComparePrice ? perUnitComparePrice * quantity : null;

        // Store the TOTAL prices for future plan toggles
        currentActivePrice = totalBasePrice;
        currentActiveComparePrice = totalComparePrice;
      }

      // Calculate subscription prices (10% off the total)
      const subscriptionPrice = totalBasePrice * {{ discount_multiplier }};
      const subscriptionPerUnit = (perUnitBasePrice / 30) * {{ discount_multiplier }};

      // Calculate one-time prices
      const onetimeQuarterlyPrice = totalBasePrice * 3 * 0.85;
      const onetimeSinglePrice = totalBasePrice;
      const onetimeQuarterlyPerUnit = (perUnitBasePrice / 30) * 0.85;
      const onetimeSinglePerUnit = perUnitBasePrice / 30;

      // Update main product price block
      const productPriceBlock = document.querySelector('.shop-product-price-block');
      const comparePriceElement = document.querySelector('.shop-compare-price');
      const savePriceElement = document.querySelector('.shop-save-price');

      // Get button price elements
      const stickyAtcPrice = document.querySelector('[id^="sticky-atc-price-"]');
      const mainAtcPrice = document.querySelector('[id^="main-atc-price-"]');

      // Get currently selected plan - check multiple ways to be robust
      let selectedPlan = document.querySelector('.plan-option.selected');

      // Fallback: check if any subscription radio is checked
      if (!selectedPlan) {
        const checkedRadio = document.querySelector('.plan-option input[type="radio"]:checked');
        if (checkedRadio) {
          selectedPlan = checkedRadio.closest('.plan-option');
        }
      }

      const isSubscription = selectedPlan && selectedPlan.getAttribute('data-plan')?.includes('subscription');
      const isOnetimeQuarterly = selectedPlan && selectedPlan.getAttribute('data-plan') === 'onetime-quarterly';

      // Determine which price to show in buttons
      let displayPrice;
      if (isSubscription) {
        displayPrice = subscriptionPrice;
      } else if (isOnetimeQuarterly) {
        displayPrice = onetimeQuarterlyPrice / 3;
      } else {
        displayPrice = totalBasePrice;
      }

      // Update sticky add to cart button price
      if (stickyAtcPrice) {
        stickyAtcPrice.textContent = formatPrice(displayPrice);
        stickyAtcPrice.style.visibility = 'visible';
      }

      // Update main add to cart button price
      if (mainAtcPrice) {
        mainAtcPrice.textContent = formatPrice(displayPrice);
        mainAtcPrice.style.visibility = 'visible';
      }

      // Also update price-item elements (standard Shopify price structure)
      // Use specific selectors to avoid conflict with compare prices
      const priceItemSelectors = [
        '#price-{{ section.id }} .price__sale .price-item--sale',
        '#price-{{ section.id }} .price__regular .price-item--regular:not(.main-comapre-price)',
        '#sticky-atc-separate-price-{{ section.id }} .price__sale .price-item--sale',
        '#sticky-atc-separate-price-{{ section.id }} .price__regular .price-item--regular:not(.main-comapre-price)'
      ];

      priceItemSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          // Only update if it's visible and not a compare-at price
          // Skip if inside price__compare-price or is main-comapre-price
          if (el.getAttribute('aria-hidden') !== 'true' &&
              !el.closest('s, del') &&
              !el.closest('.price__compare-price') &&
              !el.classList.contains('main-comapre-price')) {
            el.textContent = formatPrice(displayPrice);
            el.style.display = '';
            el.classList.remove('visibility-hidden');
          }
        });
      });

      // Update compare prices for main price and sticky ATC
      const comparePriceSelectors = [
        '#price-{{ section.id }} .price__compare-price .price-item',
        '#sticky-atc-separate-price-{{ section.id }} .price__compare-price .price-item'
      ];

      comparePriceSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          if (totalComparePrice && totalComparePrice > displayPrice) {
            el.textContent = formatPrice(totalComparePrice);
            el.style.display = '';
            el.classList.remove('visibility-hidden');
            if (el.closest('.price__compare-price')) {
              el.closest('.price__compare-price').style.display = '';
            }
          } else {
            el.style.display = 'none';
            el.classList.add('visibility-hidden');
            if (el.closest('.price__compare-price')) {
              el.closest('.price__compare-price').style.display = 'none';
            }
          }
        });
      });

      if (productPriceBlock) {
        if (isSubscription) {
          // Show subscription price in main price block
          productPriceBlock.textContent = formatPrice(subscriptionPrice);
          productPriceBlock.classList.add('on-sale');

          // Show original price as compare price
          if (comparePriceElement) {
            comparePriceElement.textContent = formatPrice(totalBasePrice);
            comparePriceElement.style.display = 'inline';
          } else {
            // Create compare price element if it doesn't exist
            const newComparePrice = document.createElement('span');
            newComparePrice.className = 'shop-compare-price';
            newComparePrice.textContent = formatPrice(totalBasePrice);
            productPriceBlock.parentNode.insertBefore(newComparePrice, productPriceBlock.nextSibling);
          }

          // Calculate and show save badge dynamically
          const savingsAmount = totalBasePrice - subscriptionPrice;
          const savingsPercent = Math.round((savingsAmount / totalBasePrice) * 100);
          if (savePriceElement) {
            savePriceElement.textContent = `SAVE ${savingsPercent}%`;
            savePriceElement.style.display = 'inline';
          } else {
            // Create save element if it doesn't exist
            const newSavePrice = document.createElement('span');
            newSavePrice.className = 'shop-save-price';
            newSavePrice.textContent = `SAVE ${savingsPercent}%`;
            productPriceBlock.parentNode.appendChild(newSavePrice);
          }
        } else if (isOnetimeQuarterly) {
          // Show quarterly bundle price in main price block
          const bundlePrice = onetimeQuarterlyPrice / 3; // Price per pack
          productPriceBlock.textContent = formatPrice(bundlePrice);
          productPriceBlock.classList.add('on-sale');

          // Show original price as compare price
          if (comparePriceElement) {
            comparePriceElement.textContent = formatPrice(totalBasePrice);
            comparePriceElement.style.display = 'inline';
          } else {
            // Create compare price element if it doesn't exist
            const newComparePrice = document.createElement('span');
            newComparePrice.className = 'shop-compare-price';
            newComparePrice.textContent = formatPrice(totalBasePrice);
            productPriceBlock.parentNode.insertBefore(newComparePrice, productPriceBlock.nextSibling);
          }

          // Calculate and show save badge dynamically
          const savingsAmount = totalBasePrice - bundlePrice;
          const savingsPercent = Math.round((savingsAmount / totalBasePrice) * 100);
          if (savePriceElement) {
            savePriceElement.textContent = `SAVE ${savingsPercent}%`;
            savePriceElement.style.display = 'inline';
          } else {
            // Create save element if it doesn't exist
            const newSavePrice = document.createElement('span');
            newSavePrice.className = 'shop-save-price';
            newSavePrice.textContent = `SAVE ${savingsPercent}%`;
            productPriceBlock.parentNode.appendChild(newSavePrice);
          }
        } else {
          // Show regular price for single one-time purchase
          productPriceBlock.textContent = formatPrice(totalBasePrice);

          // Show compare price if variant has compare_at_price
          if (totalComparePrice && totalComparePrice > totalBasePrice) {
            productPriceBlock.classList.add('on-sale');

            if (comparePriceElement) {
              comparePriceElement.textContent = formatPrice(totalComparePrice);
              comparePriceElement.style.display = 'inline';
            } else {
              // Create compare price element if it doesn't exist
              const newComparePrice = document.createElement('span');
              newComparePrice.className = 'shop-compare-price';
              newComparePrice.textContent = formatPrice(totalComparePrice);
              productPriceBlock.parentNode.insertBefore(newComparePrice, productPriceBlock.nextSibling);
            }

            // Calculate and show savings percentage
            const savingsPercent = Math.round(((totalComparePrice - totalBasePrice) / totalComparePrice) * 100);
            if (savePriceElement) {
              savePriceElement.textContent = `SAVE ${savingsPercent}%`;
              savePriceElement.style.display = 'inline';
            } else {
              // Create save element if it doesn't exist
              const newSavePrice = document.createElement('span');
              newSavePrice.className = 'shop-save-price';
              newSavePrice.textContent = `SAVE ${savingsPercent}%`;
              productPriceBlock.parentNode.appendChild(newSavePrice);
            }
          } else {
            // No compare price, remove sale styling
            productPriceBlock.classList.remove('on-sale');
            if (comparePriceElement) {
              comparePriceElement.style.display = 'none';
            }
            if (savePriceElement) {
              savePriceElement.style.display = 'none';
            }
          }
        }
      }

      // Update all subscription plans (they all have same 10% discount)
      document.querySelectorAll('[data-plan="subscription"]').forEach((plan) => {
        const currentPriceEl = plan.querySelector('.current-price');
        const originalPriceEl = plan.querySelector('.original-price');
        const perUnitEl = plan.querySelector('.price-per-unit');

        if (currentPriceEl) {
          currentPriceEl.textContent = formatPrice(subscriptionPrice);
        }
        if (originalPriceEl) {
          originalPriceEl.textContent = formatPrice(totalBasePrice);
        }
        if (perUnitEl) {
          perUnitEl.textContent = `${formatPrice(subscriptionPerUnit)} per serving`;
        }
      });

      // Update one-time single
      const onetimeSinglePlan = document.querySelector('[data-plan="onetime-single"]');
      if (onetimeSinglePlan) {
        const currentPriceEl = onetimeSinglePlan.querySelector('.current-price');
        const originalPriceEl = onetimeSinglePlan.querySelector('.original-price');
        const perUnitEl = onetimeSinglePlan.querySelector('.price-per-unit');

        if (currentPriceEl) {
          currentPriceEl.textContent = formatPrice(onetimeSinglePrice);
        }


        // Show compare price if variant has compare_at_price
        if (originalPriceEl) {
          if (totalComparePrice && totalComparePrice > totalBasePrice) {
            originalPriceEl.textContent = formatPrice(totalComparePrice);
            originalPriceEl.style.display = 'inline';
          } else {
            originalPriceEl.style.display = 'none';
          }
        }

        if (perUnitEl) {
          perUnitEl.textContent = `${formatPrice(onetimeSinglePerUnit)} per serving`;
        }
      }


      // Update one-time quarterly
      const onetimeQuarterlyPlan = document.querySelector('[data-plan="onetime-quarterly"]');
      if (onetimeQuarterlyPlan) {
        onetimeQuarterlyPlan.querySelector('.current-price').innerHTML = `${formatPrice(
          onetimeQuarterlyPrice / 3
        )}/<span class="frequency-tag">pack</span>`;
        const originalElement = onetimeQuarterlyPlan.querySelector('.original-price');
        if (originalElement) {
          originalElement.textContent = formatPrice(totalBasePrice * 3);
        }
        onetimeQuarterlyPlan.querySelector('.price-per-unit').textContent = `${formatPrice(
          onetimeQuarterlyPerUnit
        )} per serving`;
      }
    }

    // Get best available variant (first available, or first if none available)
    function getBestVariant() {
      // First try to find an available variant
      const availableVariant = variantData.find((v) => v.available);
      if (availableVariant) {
        return availableVariant;
      }

      // If no variants are available, return the first one
      return variantData[0] || null;
    }

    // Ensure a variant is selected
    function ensureVariantSelected() {
      const form = document.querySelector('form[action*="/cart/add"]');
      const variantInput = form?.querySelector('input[name="id"]');

      if (!variantInput || !variantInput.value) {
        const bestVariant = getBestVariant();
        if (bestVariant && variantInput) {
          variantInput.value = bestVariant.id;

          // Also update any variant selectors
          const variantSelectors = document.querySelectorAll(
            '.simple-variant-picker__radio, .simple-variant-picker__select'
          );
          variantSelectors.forEach((selector) => {
            if (selector.type === 'radio' && selector.value == bestVariant.id) {
              selector.checked = true;
            } else if (selector.tagName === 'SELECT') {
              selector.value = bestVariant.id;
            }
          });

          // Trigger change event to update other components
          if (variantInput) {
            variantInput.dispatchEvent(new Event('change', { bubbles: true }));
          }

          return bestVariant.id;
        }
      }

      return variantInput?.value;
    }

    function init() {
      // Ensure a variant is selected first
      const selectedVariantId = ensureVariantSelected();

      // Update prices on variant change
      document.addEventListener('change', function (e) {
        if (
          e.target.classList.contains('simple-variant-picker__radio') ||
          e.target.classList.contains('simple-variant-picker__select')
        ) {
          setTimeout(() => {
            const form = document.querySelector('form[action*="/cart/add"]');
            const variantInput = form?.querySelector('input[name="id"]');
            let variantId = variantInput?.value;

            // If no variant selected, auto-select the best one
            if (!variantId) {
              variantId = ensureVariantSelected();
            }

            if (variantId) {
              // Wait for QB to process variant change, with fallback
              // On initial load, wait longer for QB to initialize
              const fallbackDelay = isInitialized ? 300 : 600;
              waitForQBOrUpdate(variantId, fallbackDelay);
            }
          }, 50);
        }
      });

      // DISABLED: Let QB handle all quantity changes
      // Subscription widget will only respond to qb:price-updated event
      // and subscription plan changes

      // function handleQuantityChange() {
      //   setTimeout(() => {
      //     const form = document.querySelector('form[action*="/cart/add"]');
      //     const variantInput = form?.querySelector('input[name="id"]');
      //     const variantId = variantInput?.value;
      //
      //     if (variantId) {
      //       updatePricesForVariant(variantId);
      //     }
      //   }, 10);
      // }
      //
      // document.addEventListener('change', function (e) {
      //   if (e.target.name === 'quantity' || e.target.getAttribute('name') === 'quantity') {
      //     handleQuantityChange();
      //   }
      // });
      //
      // document.addEventListener('input', function (e) {
      //   if (e.target.name === 'quantity' || e.target.getAttribute('name') === 'quantity') {
      //     handleQuantityChange();
      //   }
      // });

      // DISABLED: Let QB handle all quantity button clicks
      // document.addEventListener('click', function (e) {
      //   if (e.target.closest('[data-quantity-button]') ||
      //       e.target.closest('.quantity__button')) {
      //     handleQuantityChange();
      //   }
      // });

      // DISABLED: Let QB handle quantity changes via MutationObserver
      // const qtyInput = document.querySelector('input[name="quantity"]');
      // if (qtyInput) {
      //   const qtyObserver = new MutationObserver(function() {
      //     handleQuantityChange();
      //   });
      //   qtyObserver.observe(qtyInput, {
      //     attributes: true,
      //     attributeFilter: ['value']
      //   });
      // }


      // Listen for quantity update events from quantity breaks or other sources (fallback)
      document.addEventListener('quantity-update', function(e) {
        if (e.detail && e.detail.quantity && e.detail.source !== 'coordinator') {
          setTimeout(() => {
            const form = document.querySelector('form[action*="/cart/add"]');
            const variantInput = form?.querySelector('input[name="id"]');
            const variantId = variantInput?.value;
            if (variantId) {
              updatePricesForVariant(variantId);
            }
          }, 50);
        }
      });

      // Listen for quantity break price updates
      const handlePriceUpdate = function(e) {
        // QB has already calculated, update immediately without delay
        const form = document.querySelector('form[action*="/cart/add"]');
        const variantInput = form?.querySelector('input[name="id"]');
        const variantId = variantInput?.value;

        if (variantId && e.detail) {
          // Store the current quantity from the form (QB has set it)
          const qtyInput = form?.querySelector('input[name="quantity"]');
          if (qtyInput) {
            currentQBQuantity = parseInt(qtyInput.value) || null;
          }

          // Cancel QB wait timeout since QB has fired
          if (qbWaitTimeout) {
            clearTimeout(qbWaitTimeout);
            qbWaitTimeout = null;
          }

          // Clear waiting flag
          if (waitingForQB) {
            waitingForQB = false;
            pendingVariantId = null;
          }

          // Clear any pending debounced updates since QB has the authoritative price
          if (priceUpdateTimeout) {
            clearTimeout(priceUpdateTimeout);
            priceUpdateTimeout = null;
          }

          // Use the prices from QB if available
          const qbPrice = e.detail.price;
          const qbComparePrice = e.detail.comparePrice;
          updatePricesForVariant(variantId, qbPrice, qbComparePrice);
        }
      };

      // Listen for QB price update events
      document.addEventListener('qb:price-updated', function(e) {
        // Get the QB-calculated price (already includes QB discount)
        const qbPrice = e.detail.price;
        const qbComparePrice = e.detail.comparePrice;
        const quantity = e.detail.quantity;

        // Get currently selected plan
        const selectedPlan = document.querySelector('.plan-option.selected');
        const isSubscription = selectedPlan && selectedPlan.getAttribute('data-plan')?.includes('subscription');

        if (isSubscription) {
          // Apply subscription discount ON TOP of QB price
          const subscriptionPrice = Math.round(qbPrice * {{ discount_multiplier }});
          const subscriptionCompare = qbComparePrice ? Math.round(qbComparePrice * {{ discount_multiplier }}) : null;

          // Main price display will be updated by buy button
        }
      });

      // Listen for subscription plan clicks
      document.addEventListener('click', function(e) {
        const planOption = e.target.closest('.plan-option');
        if (planOption) {
          setTimeout(() => {
            // Trigger QB to recalculate and fire event, which we'll catch above
            const qbActive = document.querySelector('.qb-wrapper .qb-option.qb-active');
            if (qbActive) {
              qbActive.click();
            }
          }, 50);
        }
      });

      // Initial price update - wait for DOM to be ready
      if (selectedVariantId) {
        setTimeout(() => {
          updatePricesForVariant(selectedVariantId);
          isInitialized = true;
        }, 200);
      } else {
        setTimeout(() => {
          isInitialized = true;
        }, 200);
      }
    }

    return {
      init: init,
      updatePrices: updatePricesForVariant,
      ensureVariant: ensureVariantSelected,
      getBestVariant: getBestVariant,
      getCurrentPrices: () => ({ price: currentActivePrice, comparePrice: currentActiveComparePrice }),
    };
  })();

  // Initialize price updater
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', window.SubscriptionPriceUpdater.init);
  } else {
    window.SubscriptionPriceUpdater.init();
  }
</script>

<style>

.subscription-widget {
  margin-top: {{ block.settings.sub_widget_section_margin_top | default: 0 }}px;
  margin-bottom: {{ block.settings.sub_widget_section_margin_bottom | default: 0 }}px;
  width: 100%;
  font-family: inherit;
  display: flex;
  flex-direction: {% if block.settings.sub_widget_sub_first %}column-reverse{% else %}column{% endif %};
  gap: {{ block.settings.sub_widget_buttons_gap }}px;
}

  .price-per {
      font-size: 12px;
      gap: 5px;
      display: flex;
      line-height: 18px;
      align-items: center;
  }

  .plan-option {
      border: {{ block.settings.sub_widget_button_border_width }}px solid {{ block.settings.sub_widget_button_border_color }};
      border-radius: {{ block.settings.sub_widget_button_border_radius }}px;
      cursor: pointer;
      position: relative;
      background: {{ block.settings.sub_widget_button_bg_color }};
      padding: {{ block.settings.sub_widget_button_padding_y | default: 12 }}px {{ block.settings.sub_widget_button_padding_x | default: 16 }}px;
      transition: border-color 0.15s ease, background-color 0.15s ease, border-width 0.15s ease;
      contain: layout style;
  }

  /* Add margin-top when badge is enabled to create space (non-compact mode only, NOT for full-width badges) */
  .subscription-widget:not(.subscription-widget--compact) .plan-option.has-badge:not(:has(.badge-full-width)) {
      margin-top: 8px;
  }

  /* First plan should not have margin-top even with badge */
  .subscription-widget:not(.subscription-widget--compact) .plan-option:first-child.has-badge {
      margin-top: 0;
  }

  /* Full-width badges in non-compact mode should have NO negative margin-top */
  .subscription-widget:not(.subscription-widget--compact) .plan-option.has-badge:has(.badge-full-width) {
      margin-top: 0 !important;
  }

  .plan-option:hover,
  .plan-option:focus,
  .plan-option:active {
      outline: none;
      box-shadow: none;
      transform: none;
  }

  .plan-option:last-child {
      margin-bottom: 0;
  }

  .plan-option.selected {
      border-color: {{ block.settings.sub_widget_button_border_color_selected }};
      border-width: {{ block.settings.sub_widget_button_border_width_selected }}px;
      background: {{ block.settings.sub_widget_button_bg_color_selected }};
      -webkit-tap-highlight-color: transparent;
  }

  .plan-option.selected .plan-title {
      color: {{ block.settings.sub_widget_active_title_color }}!important;
      font-weight: {{ block.settings.sub_widget_selected_title_weight | default: 'bold' }}!important;
  }

  .plan-option.selected .one-time-html,
  .plan-option.selected .plan-details {
      color: {{ block.settings.sub_widget_active_text_color }}!important;
  }

  .one-time-html {
      font-size: 14px;
      line-height: 1.4;
      min-height: 0;
  }

  .one-time-html:not(:empty) {
      margin-top: 4px;
  }

  .one-time-html:empty {
      display: none;
      margin: 0;
      padding: 0;
  }

  .plan-option.selected .current-price {
      color: {{ block.settings.sub_widget_active_price_color }}!important;
  }

  .plan-option.selected .original-price {
      color: {{ block.settings.sub_widget_active_compare_price_color }}!important;
  }

  .plan-option input[type="radio"] {
      {% if block.settings.sub_widget_use_radio_selectors %}
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
      {% else %}
      display: none;
      {% endif %}
  }

  .plan-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
  }

  .plan-title {
      font-size: {{ block.settings.sub_widget_subscription_title_font_size }}px ;
      font-weight: {{ block.settings.sub_widget_subscription_title_weight }};
      color: {{ block.settings.sub_widget_subscription_title_color }}!important;
      line-height: 1.5;
      margin-bottom: 0;
      display: flex;
      align-items: center;
      min-height: 20px;
  }

  .plan-title p {
      margin: 0;
      padding: 0;
  }

  /* Subscription Badge */
  .subscription-badge {
      position: absolute;
      z-index: 1;
      white-space: nowrap;
      line-height: 1;
  }

  /* One Time Badge */
  .onetime-badge {
      position: absolute;
      z-index: 1;
      white-space: nowrap;
      line-height: 1;
  }

  /* Badge Position Classes */
  .badge-top-left {
      top: 8px;
      left: 8px;
  }

  .badge-top-center:not(.badge-full-width) {
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
  }

  .badge-top-right {
      top: 8px;
      right: 8px;
  }

  .plan-discount {
      background: linear-gradient(135deg, #1b9999 0%, #158a8a 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      line-height: 1;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 4px rgba(27, 153, 153, 0.3);
  }

  .plan-details {
      color: #6c757d;
      font-size: 14px;
      line-height: 1.5;
  }

  .price-cont {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
  }

  .plan-quantity {
      margin-top: 8px;
      font-weight: 600;
      color: #495057;
  }

  .plan-pricing {
      display: flex;
      align-items: {% if block.settings.sub_widget_price_layout_row %}center{% else %}flex-end{% endif %};
      {% if block.settings.sub_widget_price_layout_row %}
        {% if block.settings.sub_widget_main_price_first %}
          flex-direction: row-reverse;
        {% else %}
          flex-direction: row;
        {% endif %}
        gap: 8px;
      {% else %}
        flex-direction: {% if block.settings.sub_widget_main_price_first %}column-reverse{% else %}column{% endif %};
        gap: 4px;
      {% endif %}
      flex-wrap: wrap;
      justify-content: flex-end;
  }

  .current-price {
    font-size: {{ block.settings.sub_widget_main_price_font_size }}px;
    font-weight: {{ block.settings.sub_widget_main_price_weight }};
    color: {{ block.settings.sub_widget_main_price_color }};
  }

  .original-price {
    font-size: {{ block.settings.sub_widget_compare_price_font_size }}px;
    font-weight: {{ block.settings.sub_widget_compare_price_weight }};
    color: {{ block.settings.sub_widget_compare_price_color }};
    text-decoration: line-through;
  }

  .savings {
      background: #fff3cd;
      color: #856404;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
  }

  .price-per-unit {
      font-size: 11px;
      color: #1b9999;
      font-weight: 600;
      background: rgba(27, 153, 153, 0.1);
      border: 1px solid rgba(27, 153, 153, 0.3);
      padding: 2px 8px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      white-space: nowrap;
  }

  .tick-list {
      display: none;
      opacity: 0;
      transform: translate3d(0, -5px, 0);
      transition: opacity 0.15s ease, transform 0.15s ease;
      will-change: opacity, transform;
      contain: layout style;
  }

  .plan-option.selected .tick-list {
      display: flex;
      flex-direction: {% if block.settings.sub_widget_frequency_above %}column-reverse{% else %}column{% endif %};
      margin-top: 16px;
      opacity: 1;
      transform: translate3d(0, 0, 0);
  }

  /* Expandable layout options for regular mode */
  .plan-option.selected .tick-list.expandable-row {
      flex-direction: row !important;
      gap: 16px;
      align-items: flex-start;
  }

  .plan-option.selected .tick-list.expandable-row .subscription-frequency {
      flex: 0 0 {{ block.settings.sub_widget_subscription_frequency_width }}%;
      min-width: 0;
      width: {{ block.settings.sub_widget_subscription_frequency_width }}%;
      margin-bottom: 0;
  }

  .plan-option.selected .tick-list.expandable-row .one-time-html {
      flex: 1 1 0%;
      min-width: 0;
      width: auto;
      margin-bottom: 0;
  }

  .tick-item {
      display: flex;
      align-items: center;
      font-size: 12px;
      color: #495057;
      margin-bottom: 8px;
  }

  .tick-item:last-child {
      margin-bottom: 0;
  }

  .tick-circle {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid #1b9999;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #1b9999;
      background-color: white;
      font-size: 10px;
      margin-right: 12px;
      flex-shrink: 0;
  }

  .plan-option {
      position: relative;
  }

  .subscription-frequency label {
      display: block;
      font-size: {{ block.settings.sub_widget_frequency_font_size }}px;
      font-weight: {{ block.settings.sub_widget_frequency_title_weight }};
      color: {{ block.settings.sub_widget_subscription_frequency_color }};
      margin-bottom: {{ block.settings.sub_widget_frequency_gap }}px;
  }
    .subscription-frequency {
      margin-bottom: {{ block.settings.sub_widget_frequency_bottom }}px;
  }

  .frequency-select {
      width: 100%;
      {% assign vertical_padding = block.settings.sub_widget_subscription_input_padding_y | default: 12 %}
      {% assign horizontal_padding = block.settings.sub_widget_subscription_input_padding_x | default: 16 %}
      {% assign icon_spacing = horizontal_padding | minus: 4 %}
      {% assign right_padding = horizontal_padding | plus: 24 %}
      padding: {{ vertical_padding }}px {{ horizontal_padding }}px;
      border: {{ block.settings.sub_widget_subscription_input_border_width }}px solid {{ block.settings.sub_widget_subscription_input_border_color }};
      border-radius: {{ block.settings.sub_widget_subscription_input_border_radius }}px !important;
      font-size: {{ block.settings.sub_widget_subscription_input_font_size }}px;
      color: {{ block.settings.sub_widget_subscription_input_text_color }};
      background: {{ block.settings.sub_widget_subscription_input_bg_color }};
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23354e4d' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right {{ icon_spacing }}px center;
      background-repeat: no-repeat;
      background-size: 16px;
      padding-right: {{ right_padding }}px;
  }

  .frequency-select:focus,
  .frequency-select:hover,
  .frequency-select:active {
      outline: none;
      box-shadow: none;
      border-color: {{ block.settings.sub_widget_subscription_input_border_color }};
  }

  .plan-cont {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      flex: 1;
  }

  /* Radio button custom styling */
  {% if block.settings.sub_widget_use_radio_selectors %}
  .plan-header {
      position: relative;
      padding-left: 30px;
  }

  .plan-header::before {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid {{ block.settings.sub_widget_radio_unchecked_color }};
      border-radius: 50%;
      background: #fff;
      z-index: 1;
      left: 0;
      top: 0;
      margin-top: 0;
  }

  .plan-option.selected .plan-header::before {
      {% if block.settings.sub_widget_radio_inverse %}
      border-color: {{ block.settings.sub_widget_radio_checked_color }};
      background: {{ block.settings.sub_widget_radio_checked_color }};
      box-shadow: inset 0 0 0 3px {{ block.settings.sub_widget_button_bg_color_selected }};
      {% else %}
      border-color: {{ block.settings.sub_widget_radio_checked_color }};
      background: transparent;
      box-shadow: inset 0 0 0 3px {{ block.settings.sub_widget_radio_checked_color }};
      {% endif %}
  }
  {% endif %}



  /* Smooth animation for plan selection */
  .plan-option {
      transform: translateY(0);
  }

  /* Loading state for dropdown */
  .frequency-select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
  }

  /* Compact Mode Styles */
  .subscription-widget--compact {
    display: flex;
    flex-direction: column;
    gap: {{ block.settings.sub_widget_buttons_gap }}px;
    overflow: visible;
  }

  .subscription-widget--compact .compact-buttons-wrapper {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: {{ block.settings.sub_widget_buttons_gap }}px;
    overflow: visible;
  }

  .subscription-widget--compact .plan-option {
    margin-bottom: 0;
  }

  /* Hide radio buttons in compact mode */
  .subscription-widget--compact .plan-option input[type="radio"] {
    display: none;
  }

  .subscription-widget--compact .plan-header::before {
    display: none !important;
  }

  .subscription-widget--compact .plan-header {
    padding-left: 0 !important;
  }

  /* Center align title in compact mode */
  .subscription-widget--compact .plan-title {
    text-align: center;
    justify-content: center;
    width: 100%;
  }

  .subscription-widget--compact .plan-cont {
    width: 100%;
  }

  /* Frequency wrapper - full width below buttons */
  .subscription-widget--compact .compact-frequency-wrapper {
    width: 100%;
    margin: 0;
    padding: 0;
  }

  .subscription-widget--compact .subscription-frequency {
    width: 100%;
    margin: 0;
    padding: 0;
    background: none;
  }

  .subscription-widget--compact .subscription-frequency label {
    display: block;
  }

  .subscription-widget--compact .frequency-select {
    width: 100%;
  }

  /* Expandable layout options */
  .compact-expandable-column {
    display: flex !important;
    flex-direction: column !important;
    gap: 12px;
    margin-top: 12px;
  }

  .compact-expandable-row {
    display: flex !important;
    flex-direction: row !important;
    gap: 12px;
    align-items: center !important;
    margin-top: 12px;
  }

  /* Ensure compact-frequency-wrapper respects the row layout */
  .subscription-widget--compact .compact-frequency-wrapper.compact-expandable-row {
    display: flex !important;
    flex-direction: row !important;
  }

  .subscription-widget--compact .compact-expandable-row .subscription-frequency {
    flex: 0 0 {{ block.settings.sub_widget_subscription_frequency_width }}%;
    min-width: 0;
    width: {{ block.settings.sub_widget_subscription_frequency_width }}% !important;
    margin: 0;
  }

  .subscription-widget--compact .compact-expandable-row .compact-subscription-html {
    flex: 1 1 0%;
    min-width: 0;
    width: auto !important;
    margin: 0;
  }

  /* Compact mode expandable content padding */
  .subscription-widget--compact .compact-frequency-wrapper {
    padding-top: {{ block.settings.sub_widget_compact_expandable_padding_top | default: 12 }}px;
    padding-bottom: {{ block.settings.sub_widget_compact_expandable_padding_bottom | default: 12 }}px;
    padding-left: {{ block.settings.sub_widget_compact_expandable_padding_left | default: 0 }}px;
    padding-right: {{ block.settings.sub_widget_compact_expandable_padding_right | default: 0 }}px;
  }
</style>

{% if block.settings.sub_widget_compact_mode %}
  {%- comment -%} COMPACT MODE STRUCTURE {%- endcomment -%}
  <div class="subscription-widget subscription-widget--compact" {{ block.shopify_attributes }}>
    <div class="compact-buttons-wrapper">
      {%- liquid
        assign button_padding_y = block.settings.sub_widget_button_padding_y | default: 12
        assign button_border_radius = block.settings.sub_widget_button_border_radius | default: 4
        assign button_border_width = block.settings.sub_widget_button_border_width | default: 1
      -%}
      {% unless block.settings.sub_widget_sub_only %}
      {%- liquid
        assign onetime_badge_full_width = block.settings.onetime_badge_full_width | default: false
      -%}
      {% if block.settings.onetime_badge_enable %}
        {%- liquid
          assign badge_height = block.settings.onetime_badge_font_size | plus: block.settings.onetime_badge_padding_top | plus: block.settings.onetime_badge_padding_bottom | plus: block.settings.onetime_badge_border_width | plus: block.settings.onetime_badge_border_width
          assign container_border = block.settings.sub_widget_button_border_width | default: 1
          assign badge_top_offset = badge_height | divided_by: 2 | plus: container_border
          assign badge_top_position = badge_top_offset | times: -1
        -%}
      {% endif %}
      <div
        class="plan-option {% unless block.settings.sub_widget_sub_auto_selected %}selected{% endunless %}{% if block.settings.onetime_badge_enable %} has-badge{% endif %}"
        onclick="selectThisPlan(this)"
        data-plan="onetime-single"
        data-selling-plan=""
        style="{% if onetime_badge_full_width == true and block.settings.onetime_badge_enable %}padding-top: calc({{ button_padding_y }}px + {{ badge_height }}px);{% if block.settings.sub_widget_compact_mode %}margin-top: -{{ badge_height }}px;{% endif %}{% endif %}"
      >
        {% if block.settings.onetime_badge_enable %}
          <span class="onetime-badge badge-{{ block.settings.onetime_badge_position }}{% if onetime_badge_full_width == true %} badge-full-width{% endif %}"
                style="
                  color: {{ block.settings.onetime_badge_text_color }};
                  font-size: {{ block.settings.onetime_badge_font_size }}px;
                  font-weight: {{ block.settings.onetime_badge_font_weight }};
                  border: {{ block.settings.onetime_badge_border_width }}px solid {{ block.settings.onetime_badge_border_color }};
                  padding: {{ block.settings.onetime_badge_padding_top }}px {{ block.settings.onetime_badge_padding_right }}px {{ block.settings.onetime_badge_padding_bottom }}px {{ block.settings.onetime_badge_padding_left }}px;
                  z-index: 1;
                  white-space: nowrap;
                  {% if onetime_badge_full_width == true %}
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    width: 100% !important;
                    margin: 0 !important;
                    text-align: center !important;
                    border-radius: calc({{ button_border_radius }}px - {{ button_border_width }}px) calc({{ button_border_radius }}px - {{ button_border_width }}px) 0 0 !important;
                  {% else %}
                    position: absolute;
                    top: {{ badge_top_position }}px;
                    border-radius: {{ block.settings.onetime_badge_border_radius }}px;
                  {% endif %}
                  {% if block.settings.onetime_badge_enable_gradient %}
                    background: {{ block.settings.onetime_badge_gradient }};
                  {% else %}
                    background-color: {{ block.settings.onetime_badge_bg_color }};
                  {% endif %}
                ">
            {{ block.settings.onetime_badge_text }}
          </span>
        {% endif %}
        <input type="radio" name="purchase-plan" value="onetime-single" checked>
        <div class="plan-header">
          <div class="plan-cont">
            <span class="plan-title">{{ block.settings.sub_widget_onetime_payment_text }}</span>
          </div>
        </div>
      </div>
      {% endunless %}

      {%- liquid
        assign sub_badge_full_width = block.settings.sub_badge_full_width | default: false
      -%}
      {% if block.settings.sub_badge_enable %}
        {%- liquid
          assign badge_height = block.settings.sub_badge_font_size | plus: block.settings.sub_badge_padding_top | plus: block.settings.sub_badge_padding_bottom | plus: block.settings.sub_badge_border_width | plus: block.settings.sub_badge_border_width
          assign container_border = block.settings.sub_widget_button_border_width | default: 1
          assign badge_top_offset = badge_height | divided_by: 2 | plus: container_border
          assign badge_top_position = badge_top_offset | times: -1
        -%}
      {% endif %}
      <div
        class="plan-option {% if block.settings.sub_widget_sub_auto_selected %}selected{% endif %}{% if block.settings.sub_badge_enable %} has-badge{% endif %}"
        onclick="selectThisPlan(this)"
        data-plan="subscription"
        data-selling-plan="{{ block.settings.sub_widget_subscription_id_1 }}"
        style="{% if sub_badge_full_width == true and block.settings.sub_badge_enable %}padding-top: calc({{ button_padding_y }}px + {{ badge_height }}px);{% if block.settings.sub_widget_compact_mode %}margin-top: -{{ badge_height }}px;{% endif %}{% endif %}"
      >
        {% if block.settings.sub_badge_enable %}
          <span class="subscription-badge badge-{{ block.settings.sub_badge_position }}{% if sub_badge_full_width == true %} badge-full-width{% endif %}"
                style="
                  color: {{ block.settings.sub_badge_text_color }};
                  font-size: {{ block.settings.sub_badge_font_size }}px;
                  font-weight: {{ block.settings.sub_badge_font_weight }};
                  border: {{ block.settings.sub_badge_border_width }}px solid {{ block.settings.sub_badge_border_color }};
                  padding: {{ block.settings.sub_badge_padding_top }}px {{ block.settings.sub_badge_padding_right }}px {{ block.settings.sub_badge_padding_bottom }}px {{ block.settings.sub_badge_padding_left }}px;
                  z-index: 1;
                  white-space: nowrap;
                  {% if sub_badge_full_width == true %}
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    width: 100% !important;
                    margin: 0 !important;
                    text-align: center !important;
                    border-radius: calc({{ button_border_radius }}px - {{ button_border_width }}px) calc({{ button_border_radius }}px - {{ button_border_width }}px) 0 0 !important;
                  {% else %}
                    position: absolute;
                    top: {{ badge_top_position }}px;
                    border-radius: {{ block.settings.sub_badge_border_radius }}px;
                  {% endif %}
                  {% if block.settings.sub_badge_enable_gradient %}
                    background: {{ block.settings.sub_badge_gradient }};
                  {% else %}
                    background-color: {{ block.settings.sub_badge_bg_color }};
                  {% endif %}
                ">
            {{ block.settings.sub_badge_text }}
          </span>
        {% endif %}
        <input type="radio" name="purchase-plan" value="subscription">
        <div class="plan-header">
          <div class="plan-cont">
            <span class="plan-title">{{ block.settings.sub_widget_subscription_payment_text }}</span>
          </div>
        </div>
      </div>
    </div>

    {%- comment -%} One-time expandable HTML - show when one-time is selected {%- endcomment -%}
    {% if block.settings.sub_widget_enable_expandable_content and block.settings.sub_widget_html_onetime_expanded != blank %}
      <div class="compact-onetime-html" style="margin-top: 12px; {% if block.settings.sub_widget_sub_auto_selected %}display: none !important;{% else %}display: block !important;{% endif %}">
        {{ block.settings.sub_widget_html_onetime_expanded }}
      </div>
    {% endif %}

    {% assign has_frequency = false %}
    {% assign frequency_count = 0 %}
    {% if block.settings.sub_widget_multiple_subscription_ids_ %}
      {% capture options_html %}
        {% if block.settings.sub_widget_subscription_id_1 != blank %}
          {% assign frequency_count = frequency_count | plus: 1 %}
          <option value="{{ block.settings.sub_widget_subscription_id_1 | escape }}">
            {{ block.settings.sub_widget_subscription_name_1 | default: 'Option 1' }}
          </option>
        {% endif %}
        {% if block.settings.sub_widget_subscription_id_2 != blank %}
          {% assign frequency_count = frequency_count | plus: 1 %}
          <option value="{{ block.settings.sub_widget_subscription_id_2 | escape }}">
            {{ block.settings.sub_widget_subscription_name_2 | default: 'Option 2' }}
          </option>
        {% endif %}
        {% if block.settings.sub_widget_subscription_id_3 != blank %}
          {% assign frequency_count = frequency_count | plus: 1 %}
          <option value="{{ block.settings.sub_widget_subscription_id_3 | escape }}">
            {{ block.settings.sub_widget_subscription_name_3 | default: 'Option 3' }}
          </option>
        {% endif %}
        {% if block.settings.sub_widget_subscription_id_4 != blank %}
          {% assign frequency_count = frequency_count | plus: 1 %}
          <option value="{{ block.settings.sub_widget_subscription_id_4 | escape }}">
            {{ block.settings.sub_widget_subscription_name_4 | default: 'Option 4' }}
          </option>
        {% endif %}
        {% if block.settings.sub_widget_subscription_id_5 != blank %}
          {% assign frequency_count = frequency_count | plus: 1 %}
          <option value="{{ block.settings.sub_widget_subscription_id_5 | escape }}">
            {{ block.settings.sub_widget_subscription_name_5 | default: 'Option 5' }}
          </option>
        {% endif %}
      {% endcapture %}
      {% assign options_html_stripped = options_html | strip %}
      {% if frequency_count > 1 %}
        {% assign has_frequency = true %}
      {% endif %}
    {% endif %}

    {% comment %} Check if expandable content exists {% endcomment %}
    {% assign has_expandable = false %}
    {% if block.settings.sub_widget_enable_expandable_content and block.settings.sub_widget_html_subscription_expanded != blank %}
      {% assign has_expandable = true %}
    {% endif %}

    {% if has_frequency or has_expandable %}
      <div class="compact-frequency-wrapper compact-expandable-{{ block.settings.sub_widget_subscription_expandable_layout }}" style="{% if block.settings.sub_widget_sub_auto_selected %}display: flex !important;{% else %}display: none !important;{% endif %}">
        {% if block.settings.sub_widget_subscription_html_position == 'before' and block.settings.sub_widget_enable_expandable_content and block.settings.sub_widget_html_subscription_expanded != blank %}
          <div class="compact-subscription-html">
            {{ block.settings.sub_widget_html_subscription_expanded }}
          </div>
        {% endif %}

        {% if has_frequency %}
          <div class="subscription-frequency">
            <label for="frequency-select">{{ block.settings.sub_widget_frequency_title }}</label>
            <select
              id="frequency-select"
              name="subscription-frequency"
              class="frequency-select"
              onchange="updateSubscriptionPlan(this)"
              onclick="event.stopPropagation()"
            >
              {{ options_html_stripped }}
            </select>
          </div>
        {% endif %}

        {% if block.settings.sub_widget_subscription_html_position == 'after' and block.settings.sub_widget_enable_expandable_content and block.settings.sub_widget_html_subscription_expanded != blank %}
          <div class="compact-subscription-html">
            {{ block.settings.sub_widget_html_subscription_expanded }}
          </div>
        {% endif %}
      </div>
    {% endif %}
  </div>

{% else %}
  {%- comment -%} REGULAR MODE STRUCTURE {%- endcomment -%}
  <div class="subscription-widget" {{ block.shopify_attributes }}>
    {%- liquid
      assign button_padding_y = block.settings.sub_widget_button_padding_y | default: 12
      assign button_border_radius = block.settings.sub_widget_button_border_radius | default: 4
      assign button_border_width = block.settings.sub_widget_button_border_width | default: 1
    -%}
    {% unless block.settings.sub_widget_sub_only %}
    {%- liquid
      assign onetime_badge_full_width = block.settings.onetime_badge_full_width | default: false
    -%}
    {% if block.settings.onetime_badge_enable %}
      {%- liquid
        assign badge_height = block.settings.onetime_badge_font_size | plus: block.settings.onetime_badge_padding_top | plus: block.settings.onetime_badge_padding_bottom | plus: block.settings.onetime_badge_border_width | plus: block.settings.onetime_badge_border_width
        assign container_border = block.settings.sub_widget_button_border_width | default: 1
        assign badge_top_offset = badge_height | divided_by: 2 | plus: container_border
        assign badge_top_position = badge_top_offset | times: -1
      -%}
    {% endif %}
    <div
      class="plan-option {% unless block.settings.sub_widget_sub_auto_selected %}selected{% endunless %}{% if block.settings.onetime_badge_enable %} has-badge{% endif %}"
      onclick="selectThisPlan(this)"
      data-plan="onetime-single"
      data-selling-plan=""
      style="{% if onetime_badge_full_width == true and block.settings.onetime_badge_enable %}margin-top: -{{ badge_height }}px; padding-top: calc({{ button_padding_y }}px + {{ badge_height }}px);{% endif %}"
    >
      {% if block.settings.onetime_badge_enable %}
        <span class="onetime-badge badge-{{ block.settings.onetime_badge_position }}{% if onetime_badge_full_width == true %} badge-full-width{% endif %}"
              style="
                color: {{ block.settings.onetime_badge_text_color }};
                font-size: {{ block.settings.onetime_badge_font_size }}px;
                font-weight: {{ block.settings.onetime_badge_font_weight }};
                border: {{ block.settings.onetime_badge_border_width }}px solid {{ block.settings.onetime_badge_border_color }};
                padding: {{ block.settings.onetime_badge_padding_top }}px {{ block.settings.onetime_badge_padding_right }}px {{ block.settings.onetime_badge_padding_bottom }}px {{ block.settings.onetime_badge_padding_left }}px;
                z-index: 1;
                white-space: nowrap;
                {% if onetime_badge_full_width == true %}
                  position: absolute !important;
                  top: 0 !important;
                  left: 0 !important;
                  right: 0 !important;
                  width: 100% !important;
                  margin: 0 !important;
                  text-align: center !important;
                  border-radius: calc({{ button_border_radius }}px - {{ button_border_width }}px) calc({{ button_border_radius }}px - {{ button_border_width }}px) 0 0 !important;
                {% else %}
                  position: absolute;
                  top: {{ badge_top_position }}px;
                  border-radius: {{ block.settings.onetime_badge_border_radius }}px;
                {% endif %}
                {% if block.settings.onetime_badge_enable_gradient %}
                  background: {{ block.settings.onetime_badge_gradient }};
                {% else %}
                  background-color: {{ block.settings.onetime_badge_bg_color }};
                {% endif %}
              ">
          {{ block.settings.onetime_badge_text }}
        </span>
      {% endif %}
      <div class="plan-header">
       <input type="radio" name="purchase-plan" value="onetime-single" checked>
        <div class="plan-cont">
          <span class="plan-title">{{ block.settings.sub_widget_onetime_payment_text }}</span>
              {% if block.settings.sub_widget_html_one_time_title != blank %}
              <div class="one-time-html">
               {{ block.settings.sub_widget_html_one_time_title }}
               </div>
              {% endif %}
        </div>
        <div class="price-cont">
          <div class="plan-pricing">
            <span class="original-price" style="display: none;">{{ current_variant.compare_at_price | money }}</span>
            <span class="current-price">{{ price | money }}</span>
          </div>
        </div>
      </div>

  {% if block.settings.sub_widget_enable_expandable_content and block.settings.sub_widget_html_onetime_expanded != blank %}
    <div class="tick-list">
      <div class="one-time-html">
        {{ block.settings.sub_widget_html_onetime_expanded }}
      </div>
    </div>
  {% endif %}

    </div>
    {% endunless %}

    <!-- Subscription -->
    {%- liquid
      assign sub_badge_full_width = block.settings.sub_badge_full_width | default: false
    -%}
    {% if block.settings.sub_badge_enable %}
      {%- liquid
        assign badge_height = block.settings.sub_badge_font_size | plus: block.settings.sub_badge_padding_top | plus: block.settings.sub_badge_padding_bottom | plus: block.settings.sub_badge_border_width | plus: block.settings.sub_badge_border_width
        assign container_border = block.settings.sub_widget_button_border_width | default: 1
        assign badge_top_offset = badge_height | divided_by: 2 | plus: container_border
        assign badge_top_position = badge_top_offset | times: -1
      -%}
    {% endif %}
    <div
      class="plan-option {% if block.settings.sub_widget_sub_auto_selected %} selected {% endif %}{% if block.settings.sub_badge_enable %} has-badge{% endif %}"
      onclick="selectThisPlan(this)"
      data-plan="subscription"
      data-selling-plan="{{ block.settings.sub_widget_subscription_id_1 }}"
      style="{% if sub_badge_full_width == true and block.settings.sub_badge_enable %}margin-top: -{{ badge_height }}px; padding-top: calc({{ button_padding_y }}px + {{ badge_height }}px);{% endif %}"
    >
    {% if block.settings.sub_badge_enable %}
      <span class="subscription-badge badge-{{ block.settings.sub_badge_position }}{% if sub_badge_full_width == true %} badge-full-width{% endif %}"
            style="
              color: {{ block.settings.sub_badge_text_color }};
              font-size: {{ block.settings.sub_badge_font_size }}px;
              font-weight: {{ block.settings.sub_badge_font_weight }};
              border: {{ block.settings.sub_badge_border_width }}px solid {{ block.settings.sub_badge_border_color }};
              padding: {{ block.settings.sub_badge_padding_top }}px {{ block.settings.sub_badge_padding_right }}px {{ block.settings.sub_badge_padding_bottom }}px {{ block.settings.sub_badge_padding_left }}px;
              z-index: 1;
              white-space: nowrap;
              {% if sub_badge_full_width == true %}
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
                margin: 0 !important;
                text-align: center !important;
                border-radius: calc({{ button_border_radius }}px - {{ button_border_width }}px) calc({{ button_border_radius }}px - {{ button_border_width }}px) 0 0 !important;
              {% else %}
                position: absolute;
                top: {{ badge_top_position }}px;
                border-radius: {{ block.settings.sub_badge_border_radius }}px;
              {% endif %}
              {% if block.settings.sub_badge_enable_gradient %}
                background: {{ block.settings.sub_badge_gradient }};
              {% else %}
                background-color: {{ block.settings.sub_badge_bg_color }};
              {% endif %}
            ">
        {{ block.settings.sub_badge_text }}
      </span>
    {% endif %}
    <div class="plan-header">
      <input type="radio" name="purchase-plan" value="subscription">
      <div class="plan-cont">
        <span class="plan-title">{{ block.settings.sub_widget_subscription_payment_text }}</span>
            {% if block.settings.sub_widget_html_subscription_title != blank %}
            <div class="one-time-html">
             {{ block.settings.sub_widget_html_subscription_title }}
             </div>
            {% endif %}
      </div>
      <div class="price-cont">
        <div class="plan-pricing">
          <span class="original-price">{{ price | money }}</span>
          <span class="current-price">{{ price | times: discount_multiplier | money }}</span>
        </div>
      </div>
    </div>

{% assign has_expandable_content = false %}
{% if block.settings.sub_widget_enable_expandable_content and block.settings.sub_widget_html_subscription_expanded != blank %}
  {% assign has_expandable_content = true %}
{% endif %}

{% assign has_frequency = false %}
{% assign frequency_count = 0 %}
{% if block.settings.sub_widget_multiple_subscription_ids_ %}
  {% capture options_html %}
    {% if block.settings.sub_widget_subscription_id_1 != blank %}
      {% assign frequency_count = frequency_count | plus: 1 %}
      <option value="{{ block.settings.sub_widget_subscription_id_1 | escape }}">
        {{ block.settings.sub_widget_subscription_name_1 | default: 'Option 1' }}
      </option>
    {% endif %}
    {% if block.settings.sub_widget_subscription_id_2 != blank %}
      {% assign frequency_count = frequency_count | plus: 1 %}
      <option value="{{ block.settings.sub_widget_subscription_id_2 | escape }}">
        {{ block.settings.sub_widget_subscription_name_2 | default: 'Option 2' }}
      </option>
    {% endif %}
    {% if block.settings.sub_widget_subscription_id_3 != blank %}
      {% assign frequency_count = frequency_count | plus: 1 %}
      <option value="{{ block.settings.sub_widget_subscription_id_3 | escape }}">
        {{ block.settings.sub_widget_subscription_name_3 | default: 'Option 3' }}
      </option>
    {% endif %}
    {% if block.settings.sub_widget_subscription_id_4 != blank %}
      {% assign frequency_count = frequency_count | plus: 1 %}
      <option value="{{ block.settings.sub_widget_subscription_id_4 | escape }}">
        {{ block.settings.sub_widget_subscription_name_4 | default: 'Option 4' }}
      </option>
    {% endif %}
    {% if block.settings.sub_widget_subscription_id_5 != blank %}
      {% assign frequency_count = frequency_count | plus: 1 %}
      <option value="{{ block.settings.sub_widget_subscription_id_5 | escape }}">
        {{ block.settings.sub_widget_subscription_name_5 | default: 'Option 5' }}
      </option>
    {% endif %}
  {% endcapture %}
  {% assign options_html_stripped = options_html | strip %}
  {% if frequency_count > 1 %}
    {% assign has_frequency = true %}
  {% endif %}
{% endif %}

{% if has_expandable_content or has_frequency %}
  <div class="tick-list expandable-{{ block.settings.sub_widget_subscription_expandable_layout }}">
    {% if block.settings.sub_widget_subscription_html_position == 'before' and has_expandable_content %}
      <div class="one-time-html">
        {{ block.settings.sub_widget_html_subscription_expanded }}
      </div>
    {% endif %}

    {% if has_frequency %}
      <div class="subscription-frequency">
        <label for="frequency-select">{{ block.settings.sub_widget_frequency_title }}</label>
        <select
          id="frequency-select"
          name="subscription-frequency"
          class="frequency-select"
          onchange="updateSubscriptionPlan(this)"
          onclick="event.stopPropagation()"
        >
          {{ options_html_stripped }}
        </select>
      </div>
    {% endif %}

    {% if block.settings.sub_widget_subscription_html_position == 'after' and has_expandable_content %}
      <div class="one-time-html">
        {{ block.settings.sub_widget_html_subscription_expanded }}
      </div>
    {% endif %}
  </div>
{% endif %}
  </div>
  </div>
{% endif %}

<script>
  // SUBSCRIPTION WIDGET: Enhanced with better dropdown integration
  window.SubscriptionWidget = (function () {
    'use strict';

    let currentSellingPlan = ''; // Default to one-time
    let initialized = false;

    // Get variant data like the simple variant picker does
    const variantData = JSON.parse(document.querySelector('.subscription-widget__variants-json').textContent);

    const DEBUG = false;

    function log(message, data = '') {
      if (DEBUG) {}
    }

    function error(message, data = '') {
    }

    // Find the product form - same logic as variant selector
    function findForm() {
      const productForm =
        document.getElementById('{{ product_form_id }}') ||
        document.querySelector('form[action*="/cart/add"]') ||
        document.querySelector('form[action="/cart/add"]') ||
        document.querySelector('form[action*="cart/add"]') ||
        document.querySelector('.product-form form') ||
        document.querySelector('#product-form') ||
        document.querySelector('form.product-form');
      return productForm;
    }

    // Get current variant ID from the form - same logic as variant selector
    function getCurrentVariantId() {
      const form = findForm();
      if (!form) return null;

      const variantInput = form.querySelector('input[name="id"]') || form.querySelector('input[name="product-id"]');

      let variantId = variantInput ? variantInput.value : null;

      // If no variant is selected, auto-select the best available one
      if (!variantId && window.SubscriptionPriceUpdater) {
        variantId = window.SubscriptionPriceUpdater.ensureVariant();
      }

      return variantId;
    }

    // Force update URL
    function updateURL() {
      try {
        const currentVariant = getCurrentVariantId();
        if (!currentVariant) return;

        const url = new URL(window.location);
        url.searchParams.set('variant', currentVariant);

        if (currentSellingPlan && currentSellingPlan !== '') {
          url.searchParams.set('selling_plan', currentSellingPlan);
        } else {
          url.searchParams.delete('selling_plan');
        }

        window.history.replaceState({}, '', url.toString());
      } catch (e) {
        // Silent fail
      }
    }

    // Override form submission completely
    function interceptAllFormSubmissions() {
      log('Setting up form submission interception...');

      // Override XMLHttpRequest for AJAX forms
      const originalXHR = window.XMLHttpRequest;
      window.XMLHttpRequest = function () {
        const xhr = new originalXHR();
        const originalSend = xhr.send;

        xhr.send = function (data) {
          // Check if this is a cart add request
          if (xhr.open && xhr._url && xhr._url.includes('/cart/add')) {
            log('Intercepting XHR cart add');

            const currentVariant = getCurrentVariantId();
            if (!currentVariant) return originalSend.call(this, data);

            // Modify the data to include our selling plan
            if (typeof data === 'string') {
              // Try to parse as JSON first (for items array)
              try {
                const jsonData = JSON.parse(data);

                // Check if this is a QB items array request
                if (jsonData.items && Array.isArray(jsonData.items)) {
                  // Check if this is a free gift
                  const isFreeGift = jsonData.items.some(item =>
                    item.properties && item.properties._free_gift === 'true'
                  );

                  if (isFreeGift) {
                    // Don't modify free gifts
                    log('Free gift detected, skipping subscription modification');
                    return originalSend.call(this, data);
                  }

                  // For QB bundles and regular items, just add selling_plan
                  if (currentSellingPlan && currentSellingPlan !== '') {
                    jsonData.items = jsonData.items.map(item => ({
                      ...item,
                      selling_plan: currentSellingPlan
                    }));
                  }
                  log('Modified XHR items array with selling plan:', jsonData.items);
                  data = JSON.stringify(jsonData);
                } else {
                  // Single item add
                  jsonData.id = currentVariant;
                  if (currentSellingPlan && currentSellingPlan !== '') {
                    jsonData.selling_plan = currentSellingPlan;
                  }
                  jsonData.quantity = jsonData.quantity || 1;
                  data = JSON.stringify(jsonData);
                  log('Modified XHR single item:', jsonData);
                }
              } catch (e) {
                // Not JSON, try as URLSearchParams
                const params = new URLSearchParams(data);
                params.set('id', currentVariant);
                if (currentSellingPlan && currentSellingPlan !== '') {
                  params.set('selling_plan', currentSellingPlan);
                }
                if (!params.has('quantity')) {
                  params.set('quantity', '1');
                }
                data = params.toString();
                log('Modified XHR data:', data);
              }
            } else if (data instanceof FormData) {
              data.set('id', currentVariant);
              if (currentSellingPlan && currentSellingPlan !== '') {
                data.set('selling_plan', currentSellingPlan);
              }
              if (!data.has('quantity')) {
                data.set('quantity', '1');
              }
              log('Modified FormData');
            }
          }

          return originalSend.call(this, data);
        };

        const originalOpen = xhr.open;
        xhr.open = function (method, url, ...args) {
          xhr._url = url;
          return originalOpen.call(this, method, url, ...args);
        };

        return xhr;
      };

      // Override fetch for modern AJAX
      const originalFetch = window.fetch;
      window.fetch = function (url, options = {}) {
        if (typeof url === 'string' && url.includes('/cart/add')) {
          // Skip if this is an upsell add
          if (options.headers && options.headers['X-Upsell-Add'] === 'true') {
            log('Skipping upsell cart add - no subscription modification');
            return originalFetch(url, options);
          }

          // Skip if this is a free gift bundle (already has selling_plan if needed)
          if (options.headers && options.headers['X-Free-Gift-Bundle'] === 'true') {
            log('Skipping free gift bundle - already has selling_plan');
            return originalFetch(url, options);
          }

          log('Intercepting fetch cart add');

          const currentVariant = getCurrentVariantId();
          if (!currentVariant) return originalFetch(url, options);

          if (options.body) {
            if (typeof options.body === 'string') {
              try {
                const data = JSON.parse(options.body);

                // Check if this is a QB items array request
                if (data.items && Array.isArray(data.items)) {
                  // QB bundles send items arrays - just add selling_plan, don't modify variants/quantities
                  // Free gifts have _free_gift property - skip those
                  const isFreeGift = data.items.some(item =>
                    item.properties && item.properties._free_gift === 'true'
                  );

                  if (isFreeGift) {
                    // Don't modify free gifts at all
                    log('Free gift detected, skipping subscription modification');
                    return originalFetch(url, options);
                  }

                  // For QB bundles and regular item arrays, just add selling_plan
                  if (currentSellingPlan && currentSellingPlan !== '') {
                    data.items = data.items.map(item => ({
                      ...item,
                      id: parseInt(item.id), // Ensure ID stays as number
                      selling_plan: currentSellingPlan
                    }));
                  }
                  log('Modified items array with selling plan:', data.items);
                } else {
                  // Single item add - use current variant and quantity
                  data.id = currentVariant;
                  if (currentSellingPlan && currentSellingPlan !== '') {
                    data.selling_plan = currentSellingPlan;
                  }
                  data.quantity = data.quantity || 1;
                  log('Modified single item:', data);
                }

                options.body = JSON.stringify(data);
              } catch (e) {
                // Try as URLSearchParams
                const params = new URLSearchParams(options.body);
                params.set('id', currentVariant);
                if (currentSellingPlan && currentSellingPlan !== '') {
                  params.set('selling_plan', currentSellingPlan);
                }
                options.body = params.toString();
              }
            } else if (options.body instanceof FormData) {
              options.body.set('id', currentVariant);
              if (currentSellingPlan && currentSellingPlan !== '') {
                options.body.set('selling_plan', currentSellingPlan);
              }
            }
          }

          return originalFetch(url, options).then((response) => {
            if (response.ok) {
              updateCartUI();
            }
            return response;
          });
        }

        return originalFetch(url, options);
      };

      // Handle regular form submissions
      document.addEventListener(
        'submit',
        function (e) {
          const form = e.target;

          if (form.action && form.action.includes('/cart/add')) {
            // Check if coordinator is already handling this
            if (window.ProductCoordinator && window.ProductCoordinator.state.isProcessing) {
              return; // Let coordinator handle it
            }

            // Check if another handler already processed this
            if (e.defaultPrevented) {
              return;
            }

            log('Intercepting form submission');

            const currentVariant = getCurrentVariantId();
            if (!currentVariant) return;

            // Remove existing selling plan inputs (but keep variant ID as is)
            form.querySelectorAll('input[name="selling_plan"]').forEach((input) => {
              input.remove();
            });

            // Add our selling plan if we have one
            if (currentSellingPlan && currentSellingPlan !== '') {
              const sellingPlanInput = document.createElement('input');
              sellingPlanInput.type = 'hidden';
              sellingPlanInput.name = 'selling_plan';
              sellingPlanInput.value = currentSellingPlan;
              form.appendChild(sellingPlanInput);
            }

            // Ensure quantity
            if (!form.querySelector('input[name="quantity"]')) {
              const qtyInput = document.createElement('input');
              qtyInput.type = 'hidden';
              qtyInput.name = 'quantity';
              qtyInput.value = '1';
              form.appendChild(qtyInput);
            }

            log('Form modified for submission', {
              variant: currentVariant,
              selling_plan: currentSellingPlan,
            });

            // For non-AJAX forms, just update cart UI after page loads
            if (!form.hasAttribute('data-ajax') && !form.classList.contains('ajax')) {
              setTimeout(() => {
                updateCartUI();
              }, 100);
            }
          }
        },
        true
      );

      log('Form interception setup complete');
    }

    // Update cart UI
    function updateCartUI() {
      fetch('/cart.js')
        .then((r) => r.json())
        .then((cart) => {
          // Update cart count
          document.querySelectorAll('[data-cart-count], .cart-count, #cart-count').forEach((el) => {
            el.textContent = cart.item_count;
          });

          // Try to open cart drawer
          setTimeout(() => {
            const triggers = [
              () => window.theme?.openCartDrawer?.(),
              () => document.querySelector('[data-cart-drawer]')?.classList.add('open'),
              () => document.querySelector('.cart-drawer')?.classList.add('active'),
              () => document.body.classList.add('cart-open'),
            ];

            triggers.forEach((trigger) => {
              try {
                trigger();
              } catch (e) {}
            });
          }, 100);
        })
        .catch((e) => {});
    }

    // Update current selling plan selection
    function updateSellingPlan(sellingPlan) {
      currentSellingPlan = sellingPlan || '';
      updateURL();

      // Trigger price update when subscription plan changes
      const currentVariant = getCurrentVariantId();
      if (currentVariant && window.SubscriptionPriceUpdater) {
        // Use stored prices to maintain QB/quantity pricing when toggling plans
        const storedPrices = window.SubscriptionPriceUpdater.getCurrentPrices();
        if (storedPrices.price !== null) {
          window.SubscriptionPriceUpdater.updatePrices(currentVariant, storedPrices.price, storedPrices.comparePrice);
        } else {
          window.SubscriptionPriceUpdater.updatePrices(currentVariant);
        }
      }

      // Also update form inputs for immediate reference
      const form = findForm();
      if (form) {
        // Clear existing selling plan inputs
        form.querySelectorAll('input[name="selling_plan"]').forEach((input) => {
          input.remove();
        });

        // Add current selling plan
        if (currentSellingPlan) {
          const sellingPlanInput = document.createElement('input');
          sellingPlanInput.type = 'hidden';
          sellingPlanInput.name = 'selling_plan';
          sellingPlanInput.value = currentSellingPlan;
          form.appendChild(sellingPlanInput);
        }
      }
    }

    // Plan selection with enhanced dropdown integration
    function selectPlan(element) {
      const planName = element.getAttribute('data-plan');
      const sellingPlan = element.getAttribute('data-selling-plan') || '';

      // Batch DOM updates in requestAnimationFrame for better performance
      requestAnimationFrame(() => {
        // Update visual selection
        const allPlans = document.querySelectorAll('.plan-option');
        allPlans.forEach((plan) => {
          if (plan === element) {
            plan.classList.add('selected');
            const radio = plan.querySelector('input[type="radio"]');
            if (radio) radio.checked = true;
          } else {
            plan.classList.remove('selected');
            const radio = plan.querySelector('input[type="radio"]');
            if (radio) radio.checked = false;
          }
        });

        // If this is a subscription plan, ensure the dropdown value matches
        if (planName === 'subscription') {
          const dropdown = element.querySelector('.frequency-select');
          if (dropdown && dropdown.value !== sellingPlan) {
            dropdown.value = sellingPlan;
          }
        }

        // Toggle frequency wrapper in compact mode (subscription HTML is inside wrapper)
        const frequencyWrapper = document.querySelector('.compact-frequency-wrapper');
        if (frequencyWrapper) {
          if (planName === 'subscription') {
            frequencyWrapper.style.setProperty('display', 'flex', 'important');
          } else {
            frequencyWrapper.style.setProperty('display', 'none', 'important');
          }
        }

        // Toggle one-time HTML in compact mode
        const onetimeHtml = document.querySelector('.compact-onetime-html');
        if (onetimeHtml) {
          if (planName === 'onetime-single') {
            onetimeHtml.style.setProperty('display', 'block', 'important');
          } else {
            onetimeHtml.style.setProperty('display', 'none', 'important');
          }
        }
      });

      // Update selling plan (non-visual)
      updateSellingPlan(sellingPlan);

      // Update prices when plan changes (non-visual)
      requestAnimationFrame(() => {
        const currentVariant = getCurrentVariantId();
        if (currentVariant && window.SubscriptionPriceUpdater) {
          const currentPrices = window.SubscriptionPriceUpdater.getCurrentPrices();
          window.SubscriptionPriceUpdater.updatePrices(
            currentVariant,
            currentPrices.price,
            currentPrices.comparePrice
          );
        }
      });

      log('Plan selected:', { plan: planName, selling_plan: sellingPlan });
    }

    // Enhanced dropdown handler
    function handleDropdownChange(selectElement, event) {
      event.stopPropagation();

      const newSellingPlan = selectElement.value;
      const subscriptionPlan = selectElement.closest('.plan-option');

      // Update the data-selling-plan attribute (only if element exists)
      if (subscriptionPlan) {
        subscriptionPlan.setAttribute('data-selling-plan', newSellingPlan);
      }

      // Update the selling plan immediately since this plan is selected
      updateSellingPlan(newSellingPlan);

      // Add visual feedback to dropdown
      selectElement.style.backgroundColor = '#f0fffe';
      setTimeout(() => {
        selectElement.style.backgroundColor = '';
      }, 300);

      // Update hidden input in form
      const form = findForm();
      if (form) {
        form.querySelectorAll('input[name="selling_plan"]').forEach((input) => {
          input.remove();
        });

        if (newSellingPlan) {
          const sellingPlanInput = document.createElement('input');
          sellingPlanInput.type = 'hidden';
          sellingPlanInput.name = 'selling_plan';
          sellingPlanInput.value = newSellingPlan;
          form.appendChild(sellingPlanInput);
        }
      }

      // Update prices when frequency changes
      const currentVariant = getCurrentVariantId();
      if (currentVariant && window.SubscriptionPriceUpdater) {
        const currentPrices = window.SubscriptionPriceUpdater.getCurrentPrices();
        window.SubscriptionPriceUpdater.updatePrices(
          currentVariant,
          currentPrices.price,
          currentPrices.comparePrice
        );
      }

      log('Dropdown changed:', { new_plan: newSellingPlan });
    }

    // Listen for variant changes from the variant selector
    function listenForVariantChanges() {
      // Listen for variant selector changes
      const variantInputs = document.querySelectorAll('.simple-variant-picker__radio, .simple-variant-picker__select');
      variantInputs.forEach((input) => {
        input.addEventListener('change', function () {
          // Small delay to let the variant selector update the form
          setTimeout(() => {
            updateURL();
            // Also trigger price update
            const currentVariant = getCurrentVariantId();
            if (currentVariant && window.SubscriptionPriceUpdater) {
              window.SubscriptionPriceUpdater.updatePrices(currentVariant);
            }
          }, 10);
        });
      });

      // Also listen for direct form changes
      const form = findForm();
      if (form) {
        const variantInput = form.querySelector('input[name="id"]');
        if (variantInput) {
          // Create a mutation observer to watch for variant ID changes
          const observer = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
              if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                updateURL();
                const currentVariant = getCurrentVariantId();

                // Update prices with current QB + subscription state
                if (currentVariant && window.SubscriptionPriceUpdater) {
                  setTimeout(() => {
                    window.SubscriptionPriceUpdater.updatePrices(currentVariant);
                  }, 100);
                }
              }
            });
          });

          observer.observe(variantInput, {
            attributes: true,
            attributeFilter: ['value'],
          });

          // Also listen for input events - DISABLED FOR TESTING
          /*
          variantInput.addEventListener('input', function () {
            updateURL();
            const currentVariant = getCurrentVariantId();
            if (currentVariant && window.SubscriptionPriceUpdater) {
              // Check if QB is active - if so, let QB handle price updates
              const qbActive = document.querySelector('.qb-wrapper .qb-option.qb-active');
              if (!qbActive) {
                // No QB active, update prices directly
                window.SubscriptionPriceUpdater.updatePrices(currentVariant);
              }
              // If QB is active, it will fire qb:price-updated event after recalculating
            }
          });
          variantInput.addEventListener('change', function () {
            updateURL();
            const currentVariant = getCurrentVariantId();
            if (currentVariant && window.SubscriptionPriceUpdater) {
              // Check if QB is active - if so, let QB handle price updates
              const qbActive = document.querySelector('.qb-wrapper .qb-option.qb-active');
              if (!qbActive) {
                // No QB active, update prices directly
                window.SubscriptionPriceUpdater.updatePrices(currentVariant);
              }
              // If QB is active, it will fire qb:price-updated event after recalculating
            }
          });
          */
        }
      }
    }

    // Initialize with enhanced setup
    function init() {
      if (initialized) return;

      // Ensure a variant is selected before doing anything else
      const selectedVariantId = getCurrentVariantId();
      if (!selectedVariantId) {
        log('No variant selected, attempting to auto-select...');
        if (window.SubscriptionPriceUpdater) {
          window.SubscriptionPriceUpdater.ensureVariant();
        }
      }

      // Set up form interception
      interceptAllFormSubmissions();

      // Set up variant change listening
      listenForVariantChanges();

      // Initialize with default selection (one-time purchase)
      const defaultElement = document.querySelector('.plan-option.selected');
      if (defaultElement) {
        const sellingPlan = defaultElement.getAttribute('data-selling-plan') || '';
        updateSellingPlan(sellingPlan);
      }

      // Restore from URL if present
      const url = new URL(window.location);
      const urlSellingPlan = url.searchParams.get('selling_plan');

      if (urlSellingPlan) {
        // Find matching plan
        const allPlans = document.querySelectorAll('.plan-option');
        for (const plan of allPlans) {
          const planSellingPlan = plan.getAttribute('data-selling-plan') || '';

          if (planSellingPlan === urlSellingPlan) {
            selectPlan(plan);
            break;
          }
        }
      }

      // Set up keyboard navigation for accessibility
      document.querySelectorAll('.plan-option').forEach((plan) => {
        plan.setAttribute('tabindex', '0');
        plan.addEventListener('keydown', function (e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            selectPlan(this);
          }
        });
      });

      initialized = true;
      log('Widget initialized successfully');
    }

    // Public API
    return {
      init: init,
      selectPlan: selectPlan,
      handleDropdownChange: handleDropdownChange,
      getCurrentSelection: () => ({
        variant: getCurrentVariantId(),
        selling_plan: currentSellingPlan,
      }),
      debug: () => ({
        currentVariant: getCurrentVariantId(),
        currentSellingPlan,
        initialized,
        form: findForm(),
      }),
    };
  })();

  // Global functions for onclick handlers with enhanced functionality
  window.selectThisPlan = function (element) {
    window.SubscriptionWidget.selectPlan(element);
  };

  window.updateSubscriptionPlan = function (selectElement, event) {
    // Enhanced dropdown handler
    window.SubscriptionWidget.handleDropdownChange(selectElement, event || window.event);
  };

  // Initialize widget with proper timing
  function initializeWidget() {
    // Initialize in the correct order
    if (window.SubscriptionPriceUpdater) {
      window.SubscriptionPriceUpdater.init();
    }
    window.SubscriptionWidget.init();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeWidget);
  } else {
    initializeWidget();
  }

  // Backup initialization
  setTimeout(initializeWidget, 1000);

  // Enhanced debug functions
  window.debugSubWidget = function () {
    const debug = window.SubscriptionWidget.debug();

    const form = debug.form;
    if (form) {
      const formData = new FormData(form);
      for (let [key, value] of formData.entries()) {
      }

      const inputs = form.querySelectorAll('input');
      inputs.forEach((input) => {
      });
    }

    const url = new URL(window.location);

    // Check dropdown state
    const dropdown = document.querySelector('.frequency-select');
    if (dropdown) {
    }

    // Check variant auto-selection
    if (window.SubscriptionPriceUpdater) {
      const bestVariant = window.SubscriptionPriceUpdater.getBestVariant();
    }
  };

  window.testDirectCartAdd = function (variantId, sellingPlanId = null) {
    const body = { id: variantId, quantity: 1 };
    if (sellingPlanId) body.selling_plan = sellingPlanId;

    fetch('/cart/add.js', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    })
      .then((response) => {
        return response.json();
      })
      .then((data) => {
        if (data.selling_plan_allocation) {
        } else if (sellingPlanId) {
        }
      })
      .catch((error) => {
      });
  };

  // Auto-select variant on page load if none selected
  window.autoSelectVariant = function () {
    if (window.SubscriptionPriceUpdater) {
      const selectedVariant = window.SubscriptionPriceUpdater.ensureVariant();
      return selectedVariant;
    }
    return null;
  };

</script>
